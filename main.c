#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in3,    ,               sensorGyro)
#pragma config(Sensor, in4,    WingPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    LiftPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  ClawSolenoid,   sensorDigitalOut)
#pragma config(Sensor, dgtl2,  TransSolenoid,  sensorDigitalOut)
#pragma config(Sensor, I2C_1,  LEncoder,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  REncoder,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LDrive,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           LDrive2,       tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           RDrive,        tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           RDrive2,       tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port6,           LLLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LRLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           RLLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           RRLift,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2);
#pragma competitionControl(Competition);
#include "Vex_Competition_Includes.c";
/*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/

#include "drive/toggle.h"
#include "drive/functions.h"

#include "auton/constants.h"
#include "auton/functions.h"
#include "auton/auton.h"

void pre_auton() {
	calibrate();
}

task autonomous() {
	//fenceStars(LEFT);
	//cubeScore(LEFT);
	SensorValue[ClawSolenoid] = 1;

	moveLift(127);
	wait10Msec(30);
	moveLift(0);


	/*
	motor[LDrive] = motor[LDrive2] = -100;
	motor[RDrive] = motor[RDrive2] = -100;

	wait10Msec(100);
	motor[LDrive] = motor[LDrive2] = 0;
	motor[RDrive] = motor[RDrive2] = 0;
	*/

	/*

	moveDrive(-100, -100);
	wait10Msec(100);
	moveDrive(0, 0);
	*/
}

bool auto = true;
bool throwLate = false;
//bool longBuffer = false;
task usercontrol() {
	Toggle claw;
	claw.state = 1;
	claw.buffer = 0;

	while (true) {
		// arcade drive
		moveDrive(-vexRT[Ch3] - vexRT[Ch1], -vexRT[Ch3] + vexRT[Ch1]);


		// lift
		if (vexRT[Btn6U]) {
			moveLift(127);
		} else if (vexRT[Btn6D]) { //todo limit
			moveLift(-127);
		} else {
			moveLift(0);
		}

		/* old transmission code
		if (vexRT[Btn8D] && (vexRT[Btn8D] != trans.buffer))  // if button is pressed and it was not pressed before
	  	trans.state = !trans.state;

	  trans.buffer = vexRT[Btn8D];
	  SensorValue[TransSolenoid] = trans.state;
	  */

	  //transmission
	  if(vexRT[Btn8D]) SensorValue[TransSolenoid] = 1;
	  if(vexRT[Btn8U]) SensorValue[TransSolenoid] = 0;



	  //claw toggle
	  if(vexRT[Btn5D] && (vexRT[Btn5D] != claw.buffer)) claw.state = !claw.state;

	  claw.buffer = vexRT[Btn5D];
	  clawState(claw.state);

		/* old claw code
		if (vexRT[Btn5D])  //close
	   	clawState(0);

	  if (vexRT[Btn5U])  //open
	   	clawState(1);
		*/


		//Test code for rotating
		/*
		if (vexRT[Btn7R]) {
			//calibrate();
			rotate(90, 1);
			wait1Msec(100);
		}
		*/

		wait1Msec(20);
	}
}
