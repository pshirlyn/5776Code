#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in3,    ,               sensorGyro)
#pragma config(Sensor, in4,    WingPot,        sensorPotentiometer)
#pragma config(Sensor, in5,    LiftPot,        sensorPotentiometer)
#pragma config(Sensor, in6,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  ClawSolenoid,   sensorDigitalOut)
#pragma config(Sensor, I2C_1,  LEncoder,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  REncoder,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           LDrive,        tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           RDrive,        tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           LLLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LRLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RLLift,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RRLift,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LWing,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RWing,         tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX2);
#pragma competitionControl(Competition);
#include "Vex_Competition_Includes.c";
/*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/

#include "drive/toggle.h"
#include "drive/functions.h"

#include "auton/constants.h"
#include "auton/functions.h"
#include "auton/auton.h"

void pre_auton() {
	calibrate();
}

task autonomous() {
	fenceStars(LEFT);
	cubeScore(LEFT);
}

bool auto = true;
bool throwLate = false;
//bool longBuffer = false;
task usercontrol() {
	Toggle claw;
	claw.state = 0;
	claw.buffer = 0;


	while (true) {
		// arcade drive
		moveDrive(vexRT[Ch3] - vexRT[Ch1], vexRT[Ch3] + vexRT[Ch1]);

		// lift
		if (vexRT[Btn6U]) {
			moveLift(127);
		} else if (vexRT[Btn6D] && SensorValue[LiftPot] > 990) {
			moveLift(-127);
		} else {
			moveLift(0);
		}

		// claw
		if(vexRT[Btn7L]) throwLate = false;
		if(vexRT[Btn7R]) throwLate = true;
		if(vexRT[Btn7U]) auto = true;
		if(vexRT[Btn7D]) auto = false;

		if (vexRT[Btn5D] && (vexRT[Btn5D] != claw.buffer))  // if button is pressed and it was not pressed before
	   	claw.state = claw.state ? 0 : 1;

	 // if(auto){
		//	if (!throwLate && SensorValue[LiftPot] > LAUNCH_ANGLE) claw.state = 1;//maybe auto release
		//	if(throwLate && SensorValue[LiftPot] > (LAUNCH_ANGLE+100)) claw.state = 1;
		//}

		claw.buffer = vexRT[Btn5D];
		clawState(claw.state);

		// wings
		if (vexRT[Btn8U]) {
			motor[LWing] = 110;
			motor[RWing] = 110;
		} else if (vexRT[Btn8D]) {
			motor[LWing] = -110;
			motor[RWing] = -110;
		} else {
			motor[LWing] = 0;
			motor[RWing] = 0;
		}

		//Test code for rotating
		/*
		if (vexRT[Btn7R]) {
			//calibrate();
			rotate(90, 1);
			wait1Msec(100);
		}
		*/

		wait1Msec(20);
	}
}
